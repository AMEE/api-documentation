<?xml version="1.0"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V5.0//EN" 
  "http://www.docbook.org/xml/5.0/dtd/docbook.dtd"
[
<!ENTITY % translations   SYSTEM "translations.ent">
%translations;
]>

<chapter xmlns:xi="http://www.w3.org/2001/XInclude" xml:id='profiles'>
  <title>Store Data</title>
  <section xml:id='store-data'>
    <title>Using &api_name; to store data</title>
    <para>
      If you have a lot of energy information, or want to keep your own application as light
      as possible, you can use &api_name; to store your &profile_item_values; permanently, so that you can
      retrieve them later.
    </para>
    <para>
	  To do this, you create <glossterm>&profiles;</glossterm>, and create a <glossterm>&profile_item;</glossterm> for
	  each set of &profile_item_values;. A &profile; can contain any number of &profile_items;. The API for creating 
	  &profile_items; is similar to that for performing one-off calculations, so there is very little extra work involved.
    </para>
  </section>
  <section xml:id='create-profile'>
    <title>Creating a &profile;</title>
    <para>
      In order to store &profile_item_values; in &api_name;, you need to create at least one &profile;. If you have multiple
      entities in your system, you can use multiple &profiles; to separate their &profile_item_values; into silos.
    </para>
    <para>
      A common use case is to have a separate &profile; for each user of a web application, but equally you could 
      have a &profile; for each office in a business application, or any number of other things. In general, the 
      smallest entity in your system will probably correspond to a &profile;.
    </para>
    <para>
		You create a profile by doing a POST request to <code>/3/profiles</code>, including <code>profile=true</code> in the request body.
	</para>
	<xi:include href='samples/post_3_profiles_profile=true.xml'/>
	<para>
		The important part of the response is the &profile; UID, which is included in the response body and in the <code>Location</code> header.
		Whenever you want to store &profile_item_values; in this &profile;, you will need the UID. You should store it in your application 
		alongside other data for the relevant entity; there is no way to search for &profiles; that match particular metadata, as all &profiles; 
		are fully anonymised.
    </para>
    <para>
		In this response, the &profile; UID is <code>FC2ODLZHCNHS</code>.
	</para>
  </section>
  <section xml:id='create-profile-item'>
    <title>Storing &profile_item_values;</title>
    <para>
      Storing &profile_item_values; in a &profile; is pretty much the same as doing one-off calculations as described in 
	  <xref linkend='doing-calculations'/>, except that
	  you POST to the <code>/items</code> path inside the profile you are using, and provide the following parameters in the POST body:
    </para>
	<itemizedlist>
		<listitem>The &category; name, in the <code>category</code> parameter.</listitem>
		<listitem>The relevant &drill_options;</listitem>
		<listitem>Some &profile_item_values;, with the form <code>value.{&profile_item_value;_name}={your_value}</code></listitem>
	</itemizedlist>
    <para>
	  The following example performs the same calculation as before, but stores it into a &profile; for later retrieval.
    </para>
	<xi:include href='samples/post_3_profiles_UID_items_category=DEFRA_transport_fuel_methodology_fuel=petrol_values.volume=500.xml'/>
    <para>
	  Apart from the <code>category</code> parameter, these are exactly the same parameters as in <xref linkend='doing-calculations'/>. 
	  The <code>category</code> parameter specified the &category; name. For one-off calculations, this is part of the URL, but here it
	  is a POST parameter.
	</para>
	<para>
	  As for creating &profiles;, the UID of the stored &profile_item; is returned in the response and the Location header.
	</para>
  </section>
  <section xml:id='retrieve-items'>
    <title>Retrieving stored &profile_item_values;</title>
    <para>
      To retrieve stored &profile_item_values;, you simply perform a GET on the &profile_item; URL, which uses the above UID.
      A sample request that includes the calculated &return_values; is shown below; you could also use the <code>values</code> matrix
	  parameter to get the original &profile_item_values; back. See <xref linkend='get-profile-item-reference'/>
      for the full details of available matrix parameters.
    </para>
	<xi:include href='samples/get_3_profiles_UID_items_UID;amounts.xml'/>
    <para>
      These responses can be filtered by time period; see below.
    </para>
    <para>
      &api_name; does not support aggregation across different categories or profiles. Often the same data
      could be stored in multiple places using different methodologies, so in order to avoid double counting, 
      the aggregation is left to the client who best understands the business logic involved.
    </para>
  </section>
  <section xml:id='list-items'>
    <title>List stored &profile_items;</title>
    <para>
	  You can also get a list of all &profile_items; that are stored in a single &profile;, by doing a GET to the items collection.
	</para>
	<xi:include href='samples/get_3_profiles_UID_items.xml'/>
	<para>
	  This request returns a list of &profile_item; UIDs, which you can use for subsequent GET requests. There are matrix parameters that
	  let you get back &return_values; or &profile_item_values; in the same request, if you want to. See <xref linkend='list-profile-items-reference'/>.
	  You can also filter items on &category;, &drill_options;, and so on.
    </para>
  </section>
  <section xml:id='build-time-series'>
    <title>Building Time Series</title>
    <para>
      Storing a single &profile_item; is useful, but most data changes over time, particularly 
      when we dealing with energy use. &api_name; allows you to store time information along 
      with your &profile_item_values;, so that you can build up a time series of data.
    </para>
    <para>
      Three parameters are available to control time information: <code>startDate</code>, <code>endDate</code>, and 
      <code>duration</code>. By providing these when you create &profile_items;, you can set the time 
      that the created &profile_item; is valid for. By default, <code>startDate</code> is "now" and 
      <code>endDate</code> is infinitely far in the future. If your data is not time-sensitive, then 
      this will be fine. However, if your data represents usage for a particular time period, you 
      can set the values explicitly. The maximum time resolution of &api_name; is 1 
      minute. If seconds are specified, they are rounded down. Note that you can't set 
      <code>endDate</code> and <code>duration</code> at the same time.
    </para>
    <para>
      All these parameters are specified in standard ISO-8601 format. For instance, the 
      following would all be valid parameters (when correctly form-encoded):
    </para>
    <programlisting>startDate=2009-08-01T14:30:00Z
endDate=2009-08-02T14:30:00-08:00
duration=PT30M</programlisting>
  </section>
  <section xml:id='naming-items'>
    <title>Naming &profile_items;</title>
    <para>
	  &api_name; treats multiple &profile_items; that have the same &category; and &drill_options; as a single time series.
      If you create two &profile_items; for the same &data_item;, and which overlap the same 
      time, then &api_name; will object, as it can't form a single consistent time series from the 
      data.
	  However, there are cases in which you might want to do this; for instance, energy used by two 
      cars of the same type at the same time. In this case, you can provide a <code>name</code> parameter when you create the &profile_items;
	  to disambiguate the two sequences. 
	</para>
	<para>
      A name is not required, but it is good practise to specify one. As the default <code>startDate</code> is "now", if you create
	  &profile_items; for the same &data_item; during the same minute, they will conflict if you do not specify a name.
    </para>
  </section>
  <section xml:id='time-series-queries'>
    <title>Time Series Queries</title>
    <para>
      If you build up a time series, you will probably want to retrieve historical data.
      You can filter which &profile_items; are returned in lists by providing <code>startDate</code> and <code>endDate</code> query 
      parameters in the GET request, using the same format as above.
    </para>
    <para>
      There are a couple of request parameters that control what is returned:
    </para>
    <section>
      <title>selectby</title>
      <table class='properties'>
        <tr><th>Option</th><th>Meaning</th></tr>
        <tr>
          <td><emphasis>unspecified</emphasis></td>
          <td>Include &profile_items; which intersects the query window.</td>
        </tr>
        <tr>
          <td><code>start</code></td>
          <td>Only include &profile_items; which start during the query window.</td>
        </tr>
        <tr>
          <td><code>end</code></td>
          <td>Only include &profile_items; which end during the query window.</td>
        </tr>
      </table>
    </section>
    <section>
      <title>mode</title>
      <table class='properties'>
        <tr><th>Option</th><th>Meaning</th></tr>
        <tr>
          <td><emphasis>unspecified</emphasis></td>
          <td>
            Get the total emission values for all items.
          </td>
        </tr>
        <tr>
          <td><code>prorata</code></td>
          <td>Get only the emissions which took place during the query window, for &data_items; that have a unit including time.</td>
        </tr>
      </table>
      <para>
        For instance, if you have a &profile_item; that lasts a week, and request just one day within that period, if you 
        do not specify mode, you will get the &return_values; for the entire week. If you specify <code>mode=prorata</code>, you will get the 
        &return_values; for that single day.
      </para>
    </section>
  </section>
</chapter>